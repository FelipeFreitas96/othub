<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sprite → Textura Similar 32×32 (ignora outline)</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Segoe UI, Arial, sans-serif; margin: 16px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .panel { border:1px solid #333; border-radius:12px; padding:12px; }
    canvas { image-rendering: pixelated; border:1px solid #333; border-radius:10px; background:#0b0b0b; }
    .hint { opacity:.8; font-size:12px; line-height:1.35; max-width:560px; }
    .ctrl { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .btn { padding:8px 10px; border:1px solid #444; border-radius:10px; background:#111; color:#fff; cursor:pointer; }
    input[type="range"] { width:220px; }
    .kv { font-size:12px; opacity:.9; min-width:95px; text-align:right; }
  </style>
</head>
<body>
  <div class="panel">
    <label>
      Upload da sprite:
      <input id="file" type="file" accept="image/*" />
    </label>
    <div class="hint" style="margin-top:8px;">
      Gera uma textura 32×32 “similar” usando paleta + grid, mas <b>ignora outline</b>:
      detecta a borda do shape (anel 1px / Npx) e exclui esses pixels da amostragem e do grid.
    </div>

    <div class="ctrl">
      <button id="download" class="btn">Baixar 32×32</button>
      <button id="rebuild" class="btn">Regerar</button>
    </div>

    <div class="ctrl">
      <span class="kv">cores (k)</span>
      <input id="k" type="range" min="4" max="24" step="1" value="10" />
      <span id="kv" class="kv">10</span>
    </div>

    <div class="ctrl">
      <span class="kv">grid</span>
      <input id="grid" type="range" min="4" max="16" step="1" value="8" />
      <span id="gridv" class="kv">8</span>
    </div>

    <div class="ctrl">
      <span class="kv">dither</span>
      <input id="dither" type="range" min="0" max="0.35" step="0.01" value="0.12" />
      <span id="ditherv" class="kv">0.12</span>
    </div>

    <div class="ctrl">
      <span class="kv">trim α</span>
      <input id="alphaT" type="range" min="1" max="254" step="1" value="8" />
      <span id="alphaTv" class="kv">8</span>
    </div>

    <div class="ctrl">
      <span class="kv">ignore border</span>
      <input id="border" type="range" min="1" max="4" step="1" value="1" />
      <span id="borderv" class="kv">1px</span>
    </div>
  </div>

  <div class="row" style="margin-top:16px;">
    <div class="panel">
      <div style="font-size:12px; opacity:.85; margin-bottom:8px;">Original (recortado)</div>
      <canvas id="srcCanvas" width="256" height="256"></canvas>
    </div>
    <div class="panel">
      <div style="font-size:12px; opacity:.85; margin-bottom:8px;">Textura similar (32×32)</div>
      <canvas id="dstCanvas" width="32" height="32"></canvas>
    </div>
  </div>

<script>
(() => {
  const file = document.getElementById('file');
  const srcCanvas = document.getElementById('srcCanvas');
  const dstCanvas = document.getElementById('dstCanvas');
  const sctx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const dctx = dstCanvas.getContext('2d', { willReadFrequently: true });

  const kEl = document.getElementById('k');
  const gridEl = document.getElementById('grid');
  const ditherEl = document.getElementById('dither');
  const alphaTEl = document.getElementById('alphaT');
  const borderEl = document.getElementById('border');

  const kv = document.getElementById('kv');
  const gridv = document.getElementById('gridv');
  const ditherv = document.getElementById('ditherv');
  const alphaTv = document.getElementById('alphaTv');
  const borderv = document.getElementById('borderv');

  const rebuildBtn = document.getElementById('rebuild');
  const downloadBtn = document.getElementById('download');

  let lastBitmap = null;

  function getAlphaBBox(imageData, threshold) {
    const { data, width, height } = imageData;
    let minX = width, minY = height, maxX = -1, maxY = -1;

    for (let y = 0; y < height; y++) {
      let rowHas = false;
      for (let x = 0; x < width; x++) {
        const a = data[(y * width + x) * 4 + 3];
        if (a > threshold) {
          rowHas = true;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
        }
      }
      if (rowHas) {
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
    if (maxX < minX || maxY < minY) return null;
    return { x: minX, y: minY, w: (maxX - minX + 1), h: (maxY - minY + 1) };
  }

  function cropToBBox(imageData, bbox) {
    const out = new ImageData(bbox.w, bbox.h);
    const src = imageData.data;
    const dst = out.data;
    const W = imageData.width;

    for (let y = 0; y < bbox.h; y++) {
      for (let x = 0; x < bbox.w; x++) {
        const si = ((bbox.y + y) * W + (bbox.x + x)) * 4;
        const di = (y * bbox.w + x) * 4;
        dst[di] = src[si];
        dst[di+1] = src[si+1];
        dst[di+2] = src[si+2];
        dst[di+3] = src[si+3];
      }
    }
    return out;
  }

  function drawCroppedPreview(cropped) {
    const max = 256;
    const scale = Math.min(max / cropped.width, max / cropped.height, 1);
    const w = Math.max(1, Math.floor(cropped.width * scale));
    const h = Math.max(1, Math.floor(cropped.height * scale));

    srcCanvas.width = w;
    srcCanvas.height = h;

    const tmp = document.createElement('canvas');
    tmp.width = cropped.width;
    tmp.height = cropped.height;
    tmp.getContext('2d').putImageData(cropped, 0, 0);

    sctx.clearRect(0, 0, w, h);
    sctx.imageSmoothingEnabled = false;
    sctx.drawImage(tmp, 0, 0, w, h);
  }

  // --- outline ignore: alpha mask -> erode -> border ring mask ---
  function buildAlphaMask(img, alphaT) {
    const { data, width:w, height:h } = img;
    const mask = new Uint8Array(w*h);
    for (let i = 0; i < w*h; i++) mask[i] = data[i*4+3] > alphaT ? 1 : 0;
    return { mask, w, h };
  }

  function erodeMask(mask, w, h, radius) {
    // radius in pixels; repeated 1px erosion radius times
    let cur = mask.slice();
    let tmp = new Uint8Array(w*h);

    const erodeOnce = () => {
      tmp.fill(0);
      for (let y = 1; y < h-1; y++) {
        for (let x = 1; x < w-1; x++) {
          const i = y*w + x;
          if (!cur[i]) continue;
          // 8-neighborhood
          const ok =
            cur[i-1] && cur[i+1] && cur[i-w] && cur[i+w] &&
            cur[i-w-1] && cur[i-w+1] && cur[i+w-1] && cur[i+w+1];
          tmp[i] = ok ? 1 : 0;
        }
      }
      // edges stay 0
      const swap = cur; cur = tmp; tmp = swap;
    };

    for (let r = 0; r < radius; r++) erodeOnce();
    return cur;
  }

  function buildIgnoreMaskForOutline(img, alphaT, borderPx) {
    const { mask, w, h } = buildAlphaMask(img, alphaT);
    const eroded = erodeMask(mask, w, h, borderPx);     // inner solid
    const ignore = new Uint8Array(w*h);                 // border ring = mask && !eroded
    for (let i = 0; i < w*h; i++) ignore[i] = (mask[i] && !eroded[i]) ? 1 : 0;
    return { ignore, w, h };
  }

  function sampleNonTransparentPixels(img, alphaT, ignoreMaskObj, maxSamples=14000) {
    const { data, width, height } = img;
    const pts = [];
    const step = Math.max(1, Math.floor(Math.sqrt((width*height) / maxSamples)));
    const ignore = ignoreMaskObj?.ignore;

    for (let y = 0; y < height; y += step) {
      for (let x = 0; x < width; x += step) {
        const idx = y * width + x;
        if (ignore && ignore[idx]) continue; // ignore outline
        const i = idx * 4;
        const a = data[i+3];
        if (a > alphaT) pts.push([data[i], data[i+1], data[i+2]]);
      }
    }
    return pts.length ? pts : [[0,0,0]];
  }

  function kmeans(points, k, iters=10) {
    const centroids = [];
    for (let i = 0; i < k; i++) {
      const p = points[(Math.random() * points.length) | 0];
      centroids.push(p.slice());
    }
    const assign = new Array(points.length).fill(0);

    for (let it = 0; it < iters; it++) {
      for (let i = 0; i < points.length; i++) {
        const [r,g,b] = points[i];
        let best = 0, bestD = 1e18;
        for (let c = 0; c < k; c++) {
          const dr = r - centroids[c][0];
          const dg = g - centroids[c][1];
          const db = b - centroids[c][2];
          const d = dr*dr + dg*dg + db*db;
          if (d < bestD) { bestD = d; best = c; }
        }
        assign[i] = best;
      }

      const sum = Array.from({length:k}, () => [0,0,0,0]);
      for (let i = 0; i < points.length; i++) {
        const c = assign[i];
        sum[c][0] += points[i][0];
        sum[c][1] += points[i][1];
        sum[c][2] += points[i][2];
        sum[c][3] += 1;
      }
      for (let c = 0; c < k; c++) {
        if (sum[c][3] > 0) {
          centroids[c][0] = sum[c][0] / sum[c][3];
          centroids[c][1] = sum[c][1] / sum[c][3];
          centroids[c][2] = sum[c][2] / sum[c][3];
        }
      }
    }
    return centroids.map(([r,g,b]) => [r|0,g|0,b|0]);
  }

  function nearestPaletteIndex(palette, r,g,b) {
    let best = 0, bestD = 1e18;
    for (let i = 0; i < palette.length; i++) {
      const dr = r - palette[i][0];
      const dg = g - palette[i][1];
      const db = b - palette[i][2];
      const d = dr*dr + dg*dg + db*db;
      if (d < bestD) { bestD = d; best = i; }
    }
    return best;
  }

  function buildDominanceGrid(cropped, palette, gridN, alphaT, ignoreMaskObj) {
    const { data, width:w, height:h } = cropped;
    const ignore = ignoreMaskObj?.ignore;
    const grid = Array.from({length:gridN}, () => Array.from({length:gridN}, () => new Int32Array(palette.length)));

    for (let y = 0; y < h; y++) {
      const gy = Math.min(gridN - 1, Math.floor(y * gridN / h));
      for (let x = 0; x < w; x++) {
        const idx = y*w + x;
        if (ignore && ignore[idx]) continue; // ignore outline
        const gx = Math.min(gridN - 1, Math.floor(x * gridN / w));
        const i = idx * 4;
        const a = data[i+3];
        if (a <= alphaT) continue;
        const p = nearestPaletteIndex(palette, data[i], data[i+1], data[i+2]);
        grid[gy][gx][p] += 1;
      }
    }

    const winners = Array.from({length:gridN}, () => new Int32Array(gridN));
    for (let gy = 0; gy < gridN; gy++) {
      for (let gx = 0; gx < gridN; gx++) {
        const hist = grid[gy][gx];
        let best = 0, bestV = -1;
        for (let i = 0; i < hist.length; i++) {
          if (hist[i] > bestV) { bestV = hist[i]; best = i; }
        }
        winners[gy][gx] = best;
      }
    }
    return winners;
  }

  function synth32FromGrid(palette, winners, ditherAmt) {
    const out = new ImageData(32, 32);
    const gridN = winners.length;

    function rand01(x,y){
      let n = (x * 73856093) ^ (y * 19349663);
      n = (n << 13) ^ n;
      return (1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0) * 0.5 + 0.5;
    }

    for (let y = 0; y < 32; y++) {
      const gy = Math.min(gridN - 1, Math.floor(y * gridN / 32));
      for (let x = 0; x < 32; x++) {
        const gx = Math.min(gridN - 1, Math.floor(x * gridN / 32));
        let idx = winners[gy][gx];

        if (ditherAmt > 0 && palette.length > 2) {
          const p = palette[idx];
          const lum = 0.2126*p[0] + 0.7152*p[1] + 0.0722*p[2];
          const r = rand01(x,y);
          if (r < ditherAmt) {
            let alt = idx, bestD = 1e18;
            for (let i = 0; i < palette.length; i++) {
              if (i === idx) continue;
              const q = palette[i];
              const qlum = 0.2126*q[0] + 0.7152*q[1] + 0.0722*q[2];
              const dl = Math.abs(qlum - lum);
              const dc = (p[0]-q[0])**2 + (p[1]-q[1])**2 + (p[2]-q[2])**2;
              const d = dc + dl * 200;
              if (d < bestD) { bestD = d; alt = i; }
            }
            idx = alt;
          }
        }

        const [rr,gg,bb] = palette[idx];
        const i = (y * 32 + x) * 4;
        out.data[i] = rr;
        out.data[i+1] = gg;
        out.data[i+2] = bb;
        out.data[i+3] = 255;
      }
    }
    return out;
  }

  function process() {
    if (!lastBitmap) return;

    const off = document.createElement('canvas');
    off.width = lastBitmap.width;
    off.height = lastBitmap.height;
    const octx = off.getContext('2d', { willReadFrequently: true });
    octx.clearRect(0, 0, off.width, off.height);
    octx.drawImage(lastBitmap, 0, 0);

    const alphaT = parseInt(alphaTEl.value, 10) || 1;
    const borderPx = parseInt(borderEl.value, 10) || 1;
    const full = octx.getImageData(0, 0, off.width, off.height);

    const bbox = getAlphaBBox(full, alphaT) || { x:0, y:0, w:off.width, h:off.height };
    const cropped = cropToBBox(full, bbox);
    drawCroppedPreview(cropped);

    const k = parseInt(kEl.value, 10) || 10;
    const gridN = parseInt(gridEl.value, 10) || 8;
    const ditherAmt = parseFloat(ditherEl.value) || 0;

    const ignoreMaskObj = buildIgnoreMaskForOutline(cropped, alphaT, borderPx);

    const pts = sampleNonTransparentPixels(cropped, alphaT, ignoreMaskObj, 16000);
    const palette = kmeans(pts, Math.min(k, 24), 12);

    const winners = buildDominanceGrid(cropped, palette, gridN, alphaT, ignoreMaskObj);
    const out32 = synth32FromGrid(palette, winners, ditherAmt);

    dctx.clearRect(0, 0, 32, 32);
    dctx.putImageData(out32, 0, 0);
  }

  function bind(range, label, fmt) {
    range.addEventListener('input', () => {
      label.textContent = fmt ? fmt(parseFloat(range.value)) : range.value;
      process();
    });
  }

  bind(kEl, kv, v => String(v|0));
  bind(gridEl, gridv, v => String(v|0));
  bind(ditherEl, ditherv, v => v.toFixed(2));
  bind(alphaTEl, alphaTv, v => String(v|0));
  bind(borderEl, borderv, v => `${(v|0)}px`);

  file.addEventListener('change', (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      lastBitmap = img;
      process();
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  rebuildBtn.addEventListener('click', process);

  downloadBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'similar_32x32_no_outline.png';
    a.href = dstCanvas.toDataURL('image/png');
    a.click();
  });
})();
</script>
</body>
</html>
